<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:pref="http://www.w3.org/2002/Math/preference"
      pref:renderer="css">

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META http-equiv="Content-Style-Type" content="text/css">

<style>
h1,h2,h3,h4,h5 {
    font-family: helvetica, arial, 'sans serif';
    text-align: left;
    color:#000000;
}


p,table,li,dl,address {
    font-family: helvetica, arial, 'sans serif';
    margin-left: 0%;
    margin-right: 3%;
}


ul,ol {
    font-family: helvetica, arial, 'sans serif';
    margin-left: 1em;
    margin-right: 0em;
    font-size: 90%;
}
</style>

<head>
<script language="JavaScript1.8" type="text/javascript"><!--
	pageModDate = "20 April 2013 03:33 PDT";
	// copyright 1997--2013 by P.B. Stark, statistics.berkeley.edu/~stark, and A. Culich, aculich@berkeley.edu
    // All rights reserved.
// -->
</script>

<title>Topic list for Reproducible and Collaborative Data Science</title>
</head>

<body>

<h1>Reproducible and Collaborative Data Science</h1>
<p>Last edited 1 August 2013</p>

<p>
   Here are topics currently being considered for inclusion in a Statistics/CS upper-division course on
   Reproducible and Collaborative Data Science.
   They fall in categories like strategies, styles, hygiene, and best practices;
   software tools; data formats and structures; numerics; and algorithms for common problems.
   The course will be taught using git, IPython Notebook, LaTeX and BibTeX.
</p>

<p>
   The desired learning outcomes for the course are:
</p>

<ul>
   <li>good habits for programming, documentation, and revision control</li>
   <li>awareness (but not necessarily mastery) of a broad variety of numerical techniques useful in
       statistics, science, and engineering</li>
   <li>awareness that there's subtlety and art to numerical methods</li>
   <li>the ability to go find or develop tools to solve problems students will face later</li>
   <li>familiarity with common issues that arise in working with real data, including missing values,
       inconsistent coding, format errors, outliers, errors, etc., and facility dealing with such issues
       </li>
</ul>

<p>
    The basic approach will be to give a scientific context/question that gives rise to each problem,
    propose an intuitively plausible numerical solution, implement that solution in software,
    examine the merits and shortcomings of that simple solution both theoretically and by simulation,
    explain the state-of-the-art method, and compare the performance of that method and the
    less sophisticated method.
    This will help students recognize that sometimes simple is good, and that sometimes
    sophistication and subtlety are required.
    It will also help students learn to think more deeply about methodology and algorithms.
</p>

<p>
    In addition, there will be a collaborative data-based term project that will involve
    identifying an interesting scientific question; acquiring data to address
    the question; cleaning and displaying the data; identifying or developing appropriate techniques
    to analyze the data; implementing those techniques and analyzing the data;
    drawing appropriate conclusions; and presenting the results both as a written report and
    a short seminar or poster.
</p>


<h2>Reproducibility and Collaboration</h2>
<ul>
    <li>Revision control systems: why?</li>
    <li>Introduction to git and github</li>
    <li>Introduction to Python and IPython notebook</li>
    <li>Some important Python libraries: numpy, scipy, matplotlib, collections, itertools</li>
    <li>Good coding hygiene</li>
    <li>Code "smells"</li>
    <li>Coding "Style".  Python style</li>
    <li>File formats</li>
    <li>Documentation and comments</li>
    <li>Introduction to LaTeX and BibTeX</li>
    <li>Reproducibility and replicability; levels of reproducibility. </li>
    <li>Coding for Collaboration. Collaborating with your future self</li>
    <li>(Resources:
    <a href="http://nbviewer.ipython.org/urls/raw.github.com/fperez/reprosw/master/Version%20Control.ipynb">
    http://nbviewer.ipython.org/urls/raw.github.com/fperez/reprosw/master/Version%20Control.ipynb</a>,
    <a href="https://github.com/swcarpentry/boot-camps/tree/2013-04-ucb">
     https://github.com/swcarpentry/boot-camps/tree/2013-04-ucb</a>)</li>
</ul>

<h2>Computational Architecture</h2>
<ul>
    <li>Parallel computing: MIMD, SIMD, Hadoop, Map-Reduce. inter-process communication</li>
    <li>Cloud computing</li>
    <li>Virtual machines</li>
    <li>Installing software on virtual machines</li>
</ul>

<h2>Bits of this and that</h2>
<ul>
    <li>Hashes and digests</li>
    <li>Hash chains</li>
    <li>Public key encryption</li>
    <li>Digital signatures</li>
</ul>

<h2>Data structures and formats</h2>
<ul>
    <li>XML</li>
    <li>JSON</li>
    <li>Unstructured data</li>
    <li>regular expressions</li>
    <li>Relational databases; SQL</li>
    <li>pickling</li>
</ul>

<h2>Simulation</h2>
<ul>
    <li>Pseudo-random number generators</li>
    <li>Tests of PRNGs: DIEHARD battery</li>
    <li>Cryptographically secure PRNGs</li>
    <li>Simulation, reproducible simulation</li>
    <li>The probability transform</li>
    <li>Simulating arbitrary distributions</li>
    <li>Pseudo random sampling. Why does the number of states of a PRNG matter?</li>
    <li>Importance sampling</li>
    <li>MCMC</li>
</ul>

<h2>Numerics and problem difficulty</h2>
<ul>
    <li>Floating point arithmetic</li>
    <li>Machine precision</li>
    <li>Underflow and overflow</li>
    <li>Error accumulation</li>
    <li>algebraic equality does not imply numerical equality: examples</li>
    <li>Interval arithmetic </li>
    <li>Arbitrary precision arithmetic</li>
    <li>Computational complexity and run times. Expected and worst-case. Linear-time algorithms,
         polynomial-time algorithms, NP-complete.</li>
    </li>Ill-posed problems</li>
</ul>

<h2>Numerical linear algebra</h2>
<ul>
    <li>Numerical linear algebra</li>
    <li>Condition number</li>
    <li>Solving linear systems: avoid inverses</li>
    <li>The QR decomposition</li>
    <li>Back substitution</li>
    <li>Least squares</li>
    <li>Orthogonalization; the Gram-Schmidt transform</li>
    <li>Eigenvalues, eigenvectors, singular value decomposition </li>
    <li>The power method</li>
    <li>Regularized least squares: ridge regression, truncated SVD</li>
</ul>

<h2>Quadrature, Differentiation, Optimization</h2>
<ul>
    <li>Numerical integration. Trapezoid method. Monte Carlo integration.</li>
    <li>Numerical differentiation; instability</li>
    <li>Root finding. Newton's method</li>
    <li>Unconstrained optimization: the problem of local minima.
    <li>steepest descent, amoeba, simulated annealing, genetic algorithms</li>
    <li>Convex optimization. local minima attain the global minimum.
    <li>Smooth vs nonsmooth convex problems.
    <li>Failure of steepest descent for nonsmooth convex problems.</li>
    <li>The SDG algorithm for nonsmooth convex problems.</li>
    <li>The BFGS algorithm: low rank approximations to the Hessian</li>
    <li>Convex Constrained optimization: Kuhn-Tucker conditions. </li>
    <li>Linear and quadratic programs. </li>
    <li>Polytopes</li>
    <li>Feasible points, extreme points</li>
    <li>Fundamental theorem of linear programming. </li>
    <li>Simplex method.</li>
    <li>Slack variables. Minimum l_1 problems. LASSO. SVM.</li>
    <li>NNLS and BVLS algorithms</li>
</ul>

<h2>Scientific algorithms and Data Visualization</h2>
<ul>
    <li>The FFT. Spectrum estimation: leakage and apodization</li>

    <li>Numerical solution of PDEs: Finite-element, finite-difference; spectral methods</li>
    <li>A posteriori error bounds</li>
    <li>Multi-grid methods and adaptive mesh refinement</li>
    <li>Tesselation</li>
    <li>Interpolation</li>
    <li>Smoothing, curve-fitting and surface fitting, splines: cubic splines, B-spline basis</li>
    <li>Visualization: plotting, contour plots, mesh plots, false-color plots. Principles and best practices
        for graphical display of data</li>
</ul>

<h2>Code efficiency</h2>
<ul>
    <li>Profiling tools</li>
    <li>vectorization and nested loops</li>
    <li>reducing duplicated evaluations</li>
    <li>abstraction, modularity</li>
    <li>(Resources:
         <a href="http://scipy-lectures.github.io/">http://scipy-lectures.github.io/</a>
         <a href="https://github.com/jrjohansson/scientific-python-lectures#online-read-only-versions">
         https://github.com/jrjohansson/scientific-python-lectures#online-read-only-versions</a>)
</ul>

<p>&copy;P.B. Stark and A. Culich.  Last edited 1 August 2013.</p>
</body>
</html>